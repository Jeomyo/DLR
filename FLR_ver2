import math
import torch
import torch.nn as nn
import torch.nn.functional as F


class FLR_Module(nn.Module):
    def __init__(
        self,
        channels,
        sigma_sp: float = 1.0,   # 5x5ë¼ì„œ 1.0~2.0 ì •ë„ ë¬´ë‚œ
        sigma_feat: float = 1.0, # feature Gaussian ì˜¨ë„
        eps: float = 1e-8,
    ):
        super().__init__()
        self.sigma_sp = sigma_sp
        self.sigma_feat = sigma_feat
        self.eps = eps

        # W: learnable projection W(F_j)
        self.W = nn.Conv2d(channels, channels, kernel_size=1, bias=True)

        # ğŸ”¹ 5x5 spatial Gaussian weights ë¯¸ë¦¬ ê³„ì‚° (dy,dx âˆˆ {-2,-1,0,1,2})
        spatial_kernel = []
        for dy in [-2, -1, 0, 1, 2]:
            for dx in [-2, -1, 0, 1, 2]:
                dist2 = dy * dy + dx * dx
                val = math.exp(-dist2 / (2.0 * (sigma_sp ** 2)))
                spatial_kernel.append(val)
        spatial_kernel = torch.tensor(spatial_kernel, dtype=torch.float32)  # [25]
        # shape: [1, 25, 1, 1]ë¡œ ë“¤ê³  ìˆë‹¤ê°€ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        self.register_buffer("spatial_kernel_5x5", spatial_kernel.view(1, 25, 1, 1))

        # 5x5 íŒ¨ì¹˜ ì¶”ì¶œìš© Unfold (padding=2 â†’ center index = 12)
        self.unfold_feat = nn.Unfold(kernel_size=5, padding=2, stride=1)
        self.unfold_inst = nn.Unfold(kernel_size=5, padding=2, stride=1)

    def forward(self, features, panoptic_mask):
        """
        features:      [B, C, H, W]
        panoptic_mask: [B, H_orig, W_orig] (long, instance IDs, sky=0)
        """
        B, C, H, W = features.shape
        device = features.device

        # 1. panopticì„ feature í•´ìƒë„ì— ë§ê²Œ nearestë¡œ ë‹¤ìš´ìƒ˜í”Œ
        inst_mask = F.interpolate(
            panoptic_mask.unsqueeze(1).float(),  # [B,1,H_orig,W_orig]
            size=(H, W),
            mode="nearest"
        ).squeeze(1)  # [B,H,W], float
        # inst=0 ì€ sky/void ë¼ê³  ê°€ì •
        inst_mask_long = inst_mask.long()

        # 2. projection W(F)
        F_proj = self.W(features)  # [B,C,H,W]

        # 3. 5x5 íŒ¨ì¹˜ ë½‘ê¸°
        #    feat_patches: [B, C*25, H*W] -> [B, C, 25, H, W]
        feat_patches = self.unfold_feat(F_proj)                    # [B,C*25,H*W]
        feat_patches = feat_patches.view(B, C, 25, H, W)          # [B,C,25,H,W]

        #    inst_patches: [B, 25, H*W] -> [B, 25, H, W]
        inst_patches = self.unfold_inst(inst_mask.unsqueeze(1))   # [B,25,H*W]
        inst_patches = inst_patches.view(B, 25, H, W)             # float

        # center index = 12 (5x5, row-major: 0..24)
        center_idx = 12
        inst_center = inst_patches[:, center_idx:center_idx+1, :, :]  # [B,1,H,W]

        # ê°™ì€ ì¸ìŠ¤í„´ìŠ¤ ì—¬ë¶€ (sky=0 í¬í•¨)
        same_inst = (inst_patches.long() == inst_center.long()).float()  # [B,25,H,W]

        # centerê°€ inst>0 (sky ì œì™¸)ì¸ í”½ì…€ë§Œ FLR ì ìš©
        center_valid = (inst_center.long() > 0).float()            # [B,1,H,W]
        same_inst = same_inst * center_valid                      # sky ì¤‘ì‹¬ì´ë©´ ì „ë¶€ 0ìœ¼ë¡œ

        # 4. feature distance term (Gaussian)
        #    center feature: [B,C,1,H,W]
        F_center = feat_patches[:, :, center_idx:center_idx+1, :, :]     # [B,C,1,H,W]
        diff = feat_patches - F_center                                   # [B,C,25,H,W]
        dist2 = (diff ** 2).sum(dim=1)                                   # [B,25,H,W]

        # feature Gaussian: exp(-||fi - fj||^2 / (2 * sigma_feat^2))
        if self.sigma_feat > 0:
            feat_gauss = torch.exp(-dist2 / (2.0 * (self.sigma_feat ** 2)))
        else:
            # sigma_feat=0 ì´ë©´ feature term ë„ê³  inst+spatialë§Œ ì‚¬ìš©
            feat_gauss = torch.ones_like(dist2)

        # 5. spatial Gaussian (precomputed 5x5 kernel) ë¸Œë¡œë“œìºìŠ¤íŠ¸
        spatial = self.spatial_kernel_5x5.to(device)                    # [1,25,1,1]

        # 6. ìµœì¢… affinity Î±_ij = same_inst * spatial * feat_gauss
        #    shapes: same_inst, feat_gauss: [B,25,H,W]
        alpha = same_inst * feat_gauss                                  # [B,25,H,W]
        alpha = alpha * spatial                                         # broadcasting: [1,25,1,1]

        # 7. ì •ê·œí™”: Î±_hat_ij = Î±_ij / (âˆ‘_j Î±_ij + eps)
        denom = alpha.sum(dim=1, keepdim=True) + self.eps               # [B,1,H,W]
        alpha_hat = alpha / denom                                       # [B,25,H,W]

        # 8. message passing: âˆ‘_j Î±_hat_ij * F_proj(j)
        #    alpha_hat: [B,25,H,W] -> [B,1,25,H,W] ë¡œ ì±„ë„ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        alpha_hat_exp = alpha_hat.unsqueeze(1)                          # [B,1,25,H,W]
        # weighted sum over 25 neighbors
        F_tilde = (feat_patches * alpha_hat_exp).sum(dim=2)             # [B,C,H,W]

        # 9. residual
        F_out = features + F_tilde
        return F_out
